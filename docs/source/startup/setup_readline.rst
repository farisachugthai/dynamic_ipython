=================================================
Setting up readline
=================================================

.. currentmodule:: default_profile.startup.30_readline


Readline Summary
----------------

Readline is implemented in the repository for a few reasons.

#) It's ubiquity in open source programming

#) In addition, it's utilized here to compensate for the weaknesses of other
   implementations.

   #) IPython's auto-completion is entirely non-configurable and exceedingly
      slow.

      #) Frequently auto-completion will time out rather than serving a response

   #) `prompt_toolkit` has a rather rigid interface for it's API. There are
      `assert`\'s all over the code base ensuring that the proper type is passed
      to a class constructor, in spite of the Python's dynamically typed
      foundation.


.. _autocompletion-setup:

Setting up autocompletion
-------------------------

IPython provides it's users the ability to add in custom completers.

To take advantage of this ability one can call `get_ipython` and add their
custom Completers via the method :meth:`set_custom_completer`.

However, all that the function does is a simple call to `types.MethodTypes` and then
tacks it on to the list bound at ``get_ipython().Completer.matchers``.


.. code-block:: ipython

   In [9]: from inspect import getdoc, getsource, getsourcelines

   In [10]: %pinfo _ip.set_custom_completer
   Signature: _ip.set_custom_completer(completer, pos=0)
   Docstring:
   Adds a new custom completer function.

   The position argument (defaults to 0) is the index in the completers
   list where you want the completer to be inserted.
   File:      ~/.local/share/virtualenvs/dynamic_ipython-mVJ3Ohov/lib/python3.7/site-packages/IPython/core/interactiveshell.py
   Type:      method

   In [11]: %pinfo2 _ip.set_custom_completer
   Signature: _ip.set_custom_completer(completer, pos=0)
   Source:
       def set_custom_completer(self, completer, pos=0):
           """Adds a new custom completer function.

           The position argument (defaults to 0) is the index in the completers
           list where you want the completer to be inserted."""

           newcomp = types.MethodType(completer,self.Completer)
           self.Completer.matchers.insert(pos,newcomp)
   File:      ~/.local/share/virtualenvs/dynamic_ipython-mVJ3Ohov/lib/python3.7/site-packages/IPython/core/interactiveshell.py
   Type:      method

   In [12]: _ip.Completer
   Out[12]: <IPython.core.completer.IPCompleter at 0x7a33dd6f50>

   In [13]: _ip.Completer.matchers
   Out[13]:
   [<bound method IPCompleter.file_matches of <IPython.core.completer.IPCompleter object at 0x7a33dd6f50>>,
    <bound method IPCompleter.magic_matches of <IPython.core.completer.IPCompleter object at 0x7a33dd6f50>>,
    <bound method IPCompleter.dict_key_matches of <IPython.core.completer.IPCompleter object at 0x7a33dd6f50>>]

Useful to see the ``magic_matches``, ``dict_key_matches``,
``file_matches`` and I think there's supposed to be a python_matches
or a keyword specific one.

Interestingly, there's also a method on the completer that returns a
:class:`IPython.utils.strdispatchers.StrDispatch` class.

If so, then that would possibly make it
the only use I've seen in the repo of this.

.. ipython::

   In [10]: from IPython.utils.strdispatch import StrDispatch

   In [11]: what = StrDispatch()
   Out[11]: <Strdispatch {}, {}>

   In [12]: what?
   Type:        StrDispatch
   String form: <Strdispatch {}, {}>
   File:
   ~/.local/share/virtualenvs/utilities-lAlPOULO/lib/python3.8/site-packages/IPython/utils/strdispatch.py
   Docstring:
   Dispatch (lookup) a set of strings / regexps for match.

   Example:

   >>> dis = StrDispatch()
   >>> dis.add_s('hei',34, priority = 4)
   >>> dis.add_s('hei',123, priority = 2)
   >>> dis.add_re('h.i', 686)
   >>> print(list(dis.flat_matches('hei')))
   [123, 34, 686]

I've formatted the below for my own sake to improve readability.

.. code-block:: ipython

   In [45]: _ip.Completer.custom_completers
   Out[45]: <Strdispatch {
         'import': <IPython.core.hooks.CommandChainDispatcher object at 0x7f0acc3defa0>,
         'from': <IPython.core.hooks.CommandChainDispatcher object at 0x7f0acc3dee50>,
         '%aimport': <IPython.core.hooks.CommandChainDispatcher object at 0x7f0acc3de370>,
         '%run': <IPython.core.hooks.CommandChainDispatcher object at 0x7f0acc3def40>,
         '%cd': <IPython.core.hooks.CommandChainDispatcher object at 0x7f0acc3def10>,
         '%reset': <IPython.core.hooks.CommandChainDispatcher object at 0x7f0acc3ded00>},
         {}
   >

   In [46]: dir(_ip.Completer.custom_completers)
   Out[46]:
    '...',
    'add_re',
    'add_s',
    'dispatch',
    'flat_matches',
    'regexs',
    's_matches',

So hooks are implemented in the completion mechanism too?
Dude I'm counting 3 nested classes and counting.

Autogenerated
--------------

.. automodule:: default_profile.startup.30_readline
   :synopsis: Setup readline keybindings and autocompletion.
   :members:
   :undoc-members:
   :show-inheritance:
