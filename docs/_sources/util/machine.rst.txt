.. currentmodule:: default_profile.util.machine

===================================
:mod:`default_profile.util.machine`
===================================

Generate a `Platform` class that can be used to identify varying
characteristics of a user's device.

Aims to clearly identify OS, CPU architecture and in the future may work
to identify varying shells and terminals.

The Platform class in this module can be easily initialized with:

>>> from default_profile.util.machine import Platform
>>> users_machine = Platform()
>>> users_machine.update_env()
>>> assert users_machine  is not None

See Also
--------
:mod:`default_profile.startup.20_aliases`
    Shows an example use case


Platform Specific Abstractions
================================

.. class:: Platform

   Abstract away platform differences.

   After toying with the initial implementation, I realized I could simply
   bind the :class:`pathlib.Path()` instance directly to `Platform`
   during initialization.

   This allows for a user to check the `sys.platform` instance, and then
   act in an appropriate manner without knowing what the
   :class:`pathlib.Path` actually initialized to.

Parameters
----------

   .. method:: __init__(shell, user_env)

      Initialize a user specific object.

      shell : |ip|, optional
          Global IPython instance.
      user_env : dict, optional
          Environment variables to add to the instance.


Attributes
----------

   .. attribute:: LOGGER : :class:`logging.Logger`

      Class attribute. Logger for the class

   .. attribute:: _sys_platform 

      Value returned by sys.platform


Sphinx Autogenerated Docs
=========================

.. automodule:: default_profile.util.machine
   :synopsis: Account for platform differences when creating a system shell.
   :members:
   :undoc-members:
   :show-inheritance:
