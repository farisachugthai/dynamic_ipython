.. currentmodule:: default_profile.util.machine

===================================
:mod:`default_profile.util.machine`
===================================

The Platform class in this module can be easily initialized with:

>>> from default_profile.util.machine import Platform
>>> users_machine = Platform()
>>> users_machine.update_env()
>>> assert users_machine  is not None

See Also
--------
:mod:`default_profile.startup.20_aliases`
    Shows an example use case


Platform Specific Abstractions
================================

.. class:: Platform

   Abstract away platform differences.

   After toying with the initial implementation, I realized I could simply
   bind the :class:`pathlib.Path()` instance directly to `Platform`
   during initialization.

   This allows for a user to check the `sys.platform` instance, and then
   act in an appropriate manner without knowing what the
   :class:`pathlib.Path` actually initialized to.

   Parameters
   ----------
   shell : |ip|, optional
       Global IPython instance.
   user_env : dict, optional
       Environment variables to add to the instance.

    .. method:: __init__

        Initialize a user specific object.

        Parameters
        ----------
        shell : |ip|, optional
            Global IPython instance.
        env : dict, optional
            User environment variables.

        Attributes
        ----------
        LOGGER : :class:`logging.Logger`
            Class attribute. Logger for the class
        _sys_platform : TODO (type?)
            Value returned by sys.platform


Sphinx Autogenerated Docs
=========================
.. automodule:: default_profile.util.machine
   :synopsis: Account for platform differences when creating a system shell.
   :members:
   :undoc-members:
   :show-inheritance:
