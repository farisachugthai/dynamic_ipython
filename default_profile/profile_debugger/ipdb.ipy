#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Vim: set ft=python:
"""
========
ipdb_ipy
========

.. module:: ipdb_ipy
    :synopsis: Run ipdb and capture args.

If an import of the ipdb module doesn't work, then use a try/except to import
:func:`IPython.get_ipython`. Return the IPython global instance or begin
configuring a tailor made instance of :class:`IPython.terminal.ipapp.TerminalIPythonApp`.

However, if the global IPython instance does exist, simply notify the user that they're
already inside an IPython session.

.. todo:: Pass arguments to this module to pre-existing IPython shell.

"""
import sys

try:
    import ipdb
except (ImportError, ModuleNotFoundError):
    # Execute the beginning of ipdb's __main__ mod.
    try:
        from IPython import get_ipython
    except (ImportError, ModuleNotFoundError):
        sys.exit('Neither ipython nor ipdb installed. Use pdb.')
    else:
        shell = get_ipython()

    if shell is None:
        # Not inside IPython
        from IPython.terminal.ipapp import TerminalIPythonApp
        from IPython.terminal.embed import InteractiveShellEmbed
        # Build a terminal app in order to force ipython to load the
        # configuration
        ipapp = TerminalIPythonApp()
        # Avoid output (banner, prints)
        ipapp.interact = False
        ipapp.initialize([])
        shell = ipapp.shell
    else:
        # Running inside IPython

        # Detect if we're inside of an embedded shell or not and display a message
        # TODO: Pass args to shell. maybe shell.run_cell(sys.argv[1:]) or something?
        if isinstance(shell, InteractiveShellEmbed):
            sys.stderr.write(
                "\nYou are currently into an embedded ipython shell,\n"
                "the configuration will not be loaded.\n\n"
            )
else:
    ipdb.run(str(sys.argv[1:]))
